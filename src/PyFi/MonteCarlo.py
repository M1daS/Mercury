'''
Created on Jul 12, 2017
 
@author: micha
'''
 

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import math

def run_montecarlo(ticker, historic_path):
   
    df = pd.read_table(historic_path, sep=',', skiprows=range(0, 2), names=['Date', 'Open', 'High', 'Low', 'Close', 'Adj.Close', 'Volume'])
    df_indexed = df.set_index('Date')
     
    start_day = df_indexed.index[0]
    end_day = df_indexed.index[-1]
    date_range = 252  # apprx number of trading days in a year
     
    # COMPOUND ANNUAL GROWTH RATE
    cagr = ((((df_indexed['Adj.Close'][-1]) / df_indexed['Adj.Close'][1])) ** (365.0 / date_range)) - 1
    # print ('CAGR =', str(round(cagr, 4) * 100) + "%")
    mu = cagr
     
    # create a series of percentage returns and calculate the annual volatility of returns
    df_indexed['Returns'] = df_indexed['Adj.Close'].pct_change()
    volatility = df_indexed['Returns'].std() * np.sqrt(252)
    # print ("Annual Volatility =", str(round(volatility, 4) * 100) + "%")
     
    # MONTE CARLO VARIABLES
    S = df_indexed['Adj.Close'][-1]  # starting stock price (i.e. last available real stock price)
    T = 252  # Number of trading days
    mu = cagr  # Return
    vol = volatility  # Volatility
     
    # create list of daily returns using random normal distribution
    daily_returns = np.random.normal(mu / T, vol / math.sqrt(T), T) + 1
    # set starting price and create price series generated by above random daily returns
    price_list = [S]
    result = []
    
    plt.clf()
    for i in range(1000): # number of simulations to run
        # create list of daily returns using random normal distribution
        daily_returns = np.random.normal(mu / T, vol / math.sqrt(T), T) + 1
        # set starting price and create price series generated by above random daily returns
        price_list = [S]
        for x in daily_returns:
            price_list.append(price_list[-1] * x)

        # plot data from each individual run which we will plot at the end
        # plt.plot(price_list)
        result.append(price_list[-1])



    mean = round(np.mean(result), 2)
    print(mean)
    percent5 = np.percentile(result, 5)
    percent95 = np.percentile(result, 95)


    outlist = [mean, percent5, percent95, volatility, cagr]
    # print(simulation)


    return outlist



# This is the mean of X amount (1000) of simulations assuming a random normal distribution
# use numpy mean function to calculate the mean of the result - calculate the mean of the distribution to get our expected value
# We can just use the numpy percentile function as follows to calculate the 5% and 95% quantiles:
# the quantiles show a 5% chance that our stock price will end up below around 5% #
# and a 5% chance it will finish above the #95% #





#GRPHAICAL REPRESENTATION


    # show the plot of multiple price series created above
 
    # path_sim = path_output + 'MonteCarlo_Simulation.png'
    # plt.savefig(path_sim, bbox_inches='tight')
    
    # plt.clf()
    # #plt.show()
    # plt.hist(result, bins=50)
    # path_hist = path_output + 'MonteCarlo_Histogram.png'
    # plt.savefig(path_hist, bbox_inches='tight')
    # plt.clf()
    # #plt.show() 

    # plt.hist(result, bins=100)
    # plt.axvline(np.percentile(result, 5), color='r', linestyle='dashed', linewidth=2)
    # plt.axvline(np.percentile(result, 95), color='r', linestyle='dashed', linewidth=2)
    # patquanthist = path_output + 'MonteCarlo_QuantHisto.png'
    # print(patquanthist)
    # plt.savefig(patquanthist, bbox_inches='tight')
    # plt.clf()
    #plt.show()
     

